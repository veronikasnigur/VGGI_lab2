// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex;          // Вершини поверхні
attribute vec3 normal;          // Нормалі для кожної вершини
uniform mat4 ModelViewProjectionMatrix;  // Модельно-видова-перспективна матриця
uniform vec3 lightPos;          // Позиція джерела світла
uniform vec3 lightColor;        // Колір джерела світла
uniform vec3 ambientColor;      // Колір амбієнтного освітлення
uniform vec3 cameraPos;         // Позиція камери
varying vec3 fragColor;         // Колір, який передається у фрагментний шейдер
varying vec3 fragNormal;        // Нормаль для обчислення освітлення

void main() {
    // Для Flat Shading, використовуємо одну нормаль для всієї грані:
    fragNormal = normalize(normal);  // Нормалізація нормалі для грані

    gl_Position = ModelViewProjectionMatrix * vec4(vertex, 1.0);  // Обчислення позиції вершини

    // Обчислення освітлення для грані
    vec3 lightDir = normalize(lightPos - vertex);
    float diff = max(dot(fragNormal, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    vec3 ambient = ambientColor;

    fragColor = ambient + diffuse;  // Загальний колір поверхні
}

`;


// Fragment shader
const fragmentShaderSource = `
precision mediump float;  // Використовуємо середню точність для значень з плаваючою комою
varying vec3 fragColor;   // Отриманий колір з вершинного шейдера
varying vec3 fragNormal;  // Нормаль для обчислення освітлення

void main() {
    // Використовуємо фіксований колір для всієї грані (Flat Shading)
    gl_FragColor = vec4(fragColor, 1.0);  // Встановлюємо колір пікселя
}

`;

